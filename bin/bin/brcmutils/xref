#!/bin/bash
# Take a stack trace and cross-reference it with a map file.

mapfile=$1
logfile=$2
mapnum=0

# If the users specified a nightly binary file, try to find the matching map
# file in the standard location (.../debug/...).
if [[ ${mapfile/_sto.bin/} != $mapfile ]] ; then
    fname=${mapfile##*/}
    path=${mapfile%/*}
    zipfile=${path}/debug/${fname/_sto.bin/.zip}
    unzip $zipfile -x eCos.elf makeapp.txt

    mapfile=${fname/_sto.bin/.map.d}
fi

# See if the user specified a number instead of a file name.  A number will
# select from the menu without printing the menu.
if [[ $mapfile != "" ]] ; then
    if [[ ! -e $mapfile ]] ; then
	(( mapnum = mapfile ))
    fi
fi
if (( mapnum != 0 )) ; then
    mapfile=""
fi

# If no map file was specified on the command line, offer a list/menu.
if [ "$mapfile" == "" ] ; then
    mapcount=0
    # Try to find a map file in a subdirectory, listing newest ones first.
    for m in `ls -t *.*map* */ecram.*map* 2>/dev/null` ; do
        ((mapcount = mapcount + 1))
        maps[mapcount]=$m
    done
    # If map files were found, prompt with a menu.
    if [ $mapcount != 0 ] ; then
        if (( mapnum == 0 )) ; then
            echo "Choose map file:"
            i=1
            while [ $i -le $mapcount ] ; do
                echo "  $i) ${maps[i]}"
                ((i = i + 1 ))
            done
            read -p "Enter 1-$mapcount: " response
            if [ "$response" == "" ] ; then
                exit
            fi
        else
            response=$mapnum
        fi
        if [ $response -lt 1 -o $response -gt $mapcount ] ; then
            echo "Error: Response must be from 1 to $mapcount"
            exit
        else
            mapfile=${maps[response]}
        fi
    else
        read -p "Enter map file name: " mapfile junk
    fi
fi

# Bail if no map file was specified.
if [ "$mapfile" == "" ] ; then
    exit
fi

# Also bail if the named file wasn't found.
if [ ! -e $mapfile ] ; then
    echo "Error: Map file not found."
    exit
fi

if [ 1 == 1 ] ; then
    rexx xref ${mapfile} ${logfile}
    exit
fi


#-----------------------------------------------------------------------------
# This is the old xref method.  It doesn't work as well on full map files
# because they can split a symbol's info across two lines if the symbol
# name is very long.  A "shortmap" file keeps each symbol's info on one line.


# There can be two kinds of map files.  A "shortmap" file is generated using
# the "nm" utility.  A true map file is generated by the linker.
maptype="none"

if [ ${mapfile:0-9} == ".shortmap" ] ; then
    maptype="shortmap"
elif [ ${mapfile:0-4} == ".map" ] ; then
    maptype="map"
elif [ ${mapfile:0-6} == ".map.d" ] ; then
    maptype="map"
fi

# echo "Map type is $maptype"

# Now prompt for a stack trace.  Traces from the regression test logs have
# two newlines between each trace line, so don't stop until we see two
# consecutive blank lines (or a line containing only a ".").

sawblank=0
addresses=""

echo "Enter stack trace, followed by two empty lines or a dot:"
while [ 1 ] ; do
    read word1 word2 word3 word4
    if [ "$word1" == "" ] ; then
        if [ $sawblank == 1 ] ; then
            break
        fi
        sawblank=1
        continue
    fi
    if [ "$word1" == "." ] ; then
        break
    fi
    addresses="$addresses $word2"
    thisaddress=$word2
    sawblank=0
done

# Generate a grep command to search the map file for all the entry points.

grepline=""

if [ "$addresses" == "" ] ; then
    exit
fi

for a in $addresses ; do
    grepline="$grepline -e $a"
done

# Use the grep command to find the desired lines.  For full map files, we don't
# want lines which have the object file names.

grep $grepline $mapfile | grep -v "\.o\$" >temp.xref

if [ $? != 0 ] ; then
    echo "Error: No matching references found in map file."
    exit
fi

# Read the list of map lines and parse out the function names.

typeset -a words

for a in $addresses ; do
    thisline=`grep $a temp.xref | tail -1`
    if [ "$thisline" == "" ] ; then
        echo "$a no match"
        continue
    fi
    thisline=`echo $thisline`
    words=($thisline)
    if [ $maptype == shortmap ] ; then
        thisfunction=${words[2]}
    else
        thisaddress=${words[0]}
        thisfunction=${words[1]}
        if [ "${thisaddress:0:2}" != "0x" -o "${thisfunction:0:2}" == "0x" ] ; then
            continue
        fi
        thisaddress=${thisaddress:0-8}
    fi
    if [ "${thisline:0:10}" == "0x00000000" ] ; then
        thisline=${thisline:10}
    fi
    echo "$thisline"
#    echo "matched $thisaddress $thisfunction"
done

rm temp.xref

exit
